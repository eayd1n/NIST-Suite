//! This module contains useful functions to support the statistical tests from the NIST suite.

use crate::customtypes;
use anyhow::{Context, Result};
use openssl::rand::rand_bytes;
use std::fs::File;
use std::io::{Read, Write};

/// Generate specific number of random bytes.
///
/// # Arguments
///
/// num_bytes - Number of random bytes to be generated
///
/// # Return
///
/// Ok(random_bytes) - A vector containing the generated bytes
/// Err(err) - Some error occured
pub fn get_random_bytes(num_bytes: usize) -> Result<Vec<u8>> {
    log::trace!("utils::get_random_bytes()");

    // check number of bytes to be generated
    if num_bytes == 0 {
        anyhow::bail!("At least one byte has to be passed!");
    }

    // now generate random numbers
    let mut random_bytes: Vec<u8> = vec![0; num_bytes];
    rand_bytes(&mut random_bytes).with_context(|| "Failed to generate random bytes")?;

    Ok(random_bytes)
}

/// Evaluate passed bit string.
///
/// # Arguments
///
/// test_name - The name of the test the evaluation is made for
/// bit_string - The bit string to evaluate
/// recommended_size - Log a warning if passed bit string has not recommended size
///
/// # Return
///
/// Ok(length) - Return length of bit string if everything is okay
/// Err(err) - Some error occured
pub fn evaluate_bit_string(
    test_name: customtypes::Test,
    bit_string: &str,
    recommended_size: usize,
) -> Result<usize> {
    log::trace!("utils::evaluate_bit_string()");

    // check validity of passed bit string
    if bit_string.is_empty() || bit_string.chars().any(|c| c != '0' && c != '1') {
        anyhow::bail!("Bit string is either empty or contains invalid character(s)");
    }

    let length = bit_string.len();
    log::debug!("Bit string has the length {}", length);

    // If bit string has not the recommended size, it is not an error but log a warning anyways
    if length < recommended_size {
        log::warn!(
            "Recommended size for {} is at least {} bits. Consider imprecision when calculating p-value",
            test_name,
            recommended_size
        );
    }

    Ok(length)
}

/// Convert a given vector of hexadecimal bytes into a bit string.
///
/// # Arguments
///
/// hex_bytes - A byte vector to be converted
///
/// # Return
///
/// Ok(bit_string) - The bit string converted from given hex string
/// Err(err) - Some error occured
pub fn hex_bytes_to_bit_string(hex_bytes: Vec<u8>) -> Result<String> {
    log::trace!("utils::hex_bytes_to_bit_string()");

    // check if given vector is empty or not
    if hex_bytes.is_empty() {
        anyhow::bail!("No hexadecimal bytes to convert passed!");
    }

    // now convert hex bytes to bit string
    let bit_string = hex_bytes
        .iter()
        .flat_map(|&byte| {
            (0..8)
                .rev()
                .map(move |i| if byte & (1 << i) == 0 { '0' } else { '1' })
        })
        .collect();

    log::info!(
        "Successfully converted {} hex bytes to bit string",
        hex_bytes.len()
    );

    Ok(bit_string)
}

/// Read file containing already generated random bytes.
///
/// # Arguments
///
/// file_path - The path to the file containing random bytes
///
/// # Return
///
/// Ok(random_bytes) - The read random bytes
/// Err(err) - Some error occured
pub fn read_random_bytes(file_path: &str) -> Result<Vec<u8>> {
    log::trace!("utils::read_random_bytes()");

    // open the file
    let mut file =
        File::open(file_path).with_context(|| format!("Failed to open file '{}'", file_path))?;

    // read the contents of the file into a string
    let mut hex_string = String::new();
    file.read_to_string(&mut hex_string)
        .with_context(|| format!("Failed to read file '{}'", file_path))?;

    // remove any whitespace characters from the string
    hex_string.retain(|c| !c.is_whitespace());

    // parse the hexadecimal string into bytes
    let random_bytes = hex::decode(&hex_string)
        .map_err(|e| anyhow::anyhow!("Failed to parse hexadecimal string: {}", e))?;

    log::info!("Successfully read {} random bytes", random_bytes.len());

    Ok(random_bytes)
}

/// Write random bytes into file.
///
/// # Arguments
///
/// random_bytes - Vector containing random bytes
/// file_path - File to write the random bytes into
///
/// # Return
///
/// Ok() - Writing random bytes into file worked fine
/// Err(err) - Some error occured
pub fn write_random_bytes(random_bytes: Vec<u8>, file_path: &str) -> Result<()> {
    log::trace!("utils::write_random_bytes()");

    // check whether passed vector is empty or not
    if random_bytes.is_empty() {
        anyhow::bail!("No random bytes passed to write into file!");
    }

    // convert bytes to hexadecimal string
    let hex_string: String = random_bytes
        .iter()
        .map(|b| format!("{:02X}", b))
        .collect::<Vec<String>>()
        .join("");

    // Open the file for writing
    let mut file = File::create(file_path)
        .with_context(|| format!("Failed to create file '{}'", file_path))?;

    // Write the bytes to the file
    file.write_all(hex_string.as_bytes())
        .with_context(|| format!("Failed to write to file '{}'", file_path))?;

    log::info!(
        "Successfully wrote {} random bytes to '{}'",
        random_bytes.len(),
        file_path
    );

    Ok(())
}
