//! This module contains useful functions to support the statistical tests from the NIST suite.

use anyhow::{Context, Result};
use openssl::rand::rand_bytes;
use std::fs::File;
use std::io::{Read, Write};

/// Generate specific number of random bytes.
///
/// # Arguments
///
/// num_bytes - Number of random bytes to be generated
///
/// # Return
///
/// Ok(random_bytes) - A vector containing the generated bytes
/// Err(err) - Some error occured
pub fn get_random_bytes(num_bytes: usize) -> Result<Vec<u8>> {
    log::trace!("utils::get_random_bytes()");

    // check number of bytes to be generated
    if num_bytes == 0 {
        anyhow::bail!("At least one byte has to be passed!");
    }

    // now generate random numbers
    let mut random_bytes: Vec<u8> = vec![0; num_bytes];
    rand_bytes(&mut random_bytes).with_context(|| "Failed to generate random bytes")?;

    Ok(random_bytes)
}

/// Evaluate passed bit string.
///
/// # Arguments
///
/// bit_string - The bit string to evaluate
/// recommended_size - Log a warning if passed bit string has not recommended size
///
/// # Return
///
/// Ok(length) - Return length of bit string if everything is okay
/// Err(err) - Some error occured
pub fn evaluate_bit_string(bit_string: &str, recommended_size: usize) -> Result<usize> {
    log::trace!("utils::evaluate_bit_string()");

    // check validity of passed bit string
    if bit_string.is_empty() || bit_string.chars().any(|c| c != '0' && c != '1') {
        anyhow::bail!("Bit string is either empty or contains invalid character(s)");
    }

    let length = bit_string.len();
    log::debug!("Bit string has the length {}", length);

    // If bit string has not the recommended size, it is not an error but log a warning anyways
    if length < recommended_size {
        log::warn!(
            "Recommended size is at least {} bits. Consider imprecision when calculating p-value",
            recommended_size
        );
    }

    Ok(length)
}

/// Convert a given hexadecimal string into a bit string.
///
/// # Arguments
///
/// hex_string - An hexadecimal string to be converted
///
/// # Return
///
/// Ok(bit_string) - The bit string converted from given hex string
/// Err(err) - Some error occured
pub fn hex_to_bit_string(hex_string: &str) -> Result<String> {
    log::trace!("utils::hex_to_bit_string()");

    // check if given string is empty or not
    if hex_string.is_empty() {
        anyhow::bail!("No hexadecimal string to convert passed!");
    }

    // remove potential "0x" in the beginning of an hex string
    let hex_string = if hex_string.starts_with("0x") {
        &hex_string[2..]
    } else {
        hex_string
    };

    // validate the passed string contains valid hex bytes
    if !hex_string.chars().all(|c| c.is_ascii_hexdigit()) {
        anyhow::bail!("Invalid hex string: '{}'", hex_string);
    }

    // now convert valid hex string to bit string
    let mut bit_string = String::new();

    for hex_char in hex_string.chars() {
        let byte = hex_char.to_digit(16).unwrap() as u8;
        let binary_str = format!("{:04b}", byte);
        bit_string.push_str(&binary_str);
    }

    log::debug!("Converted '{}' to '{}'", hex_string, &bit_string);
    log::info!("Successfully converted hexadecimal string to bit string");

    Ok(bit_string)
}

/// Read file containing already generated random bytes (or bits) to let the NIST suite testing
/// them.
///
/// # Arguments
///
/// file_path - The path to the file containing random bytes/bits
///
/// # Return
///
/// Ok(bit_string) - The read bit string. If hex bytes were stored in the file, convert them to
/// binary string
/// Err(err) - Some error occured
pub fn read_random_bytes(file_path: &str) -> Result<String> {
    log::trace!("utils::read_random_bytes()");

    // open the file
    let mut file =
        File::open(file_path).with_context(|| format!("Failed to open file '{}'", file_path))?;

    // read the contents of the file into a buffer
    let mut buffer = String::new();
    file.read_to_string(&mut buffer)
        .with_context(|| format!("Failed to read file '{}'", file_path))?;

    // determine if the content is in hex format
    let is_hex = buffer.chars().all(|c| c.is_ascii_hexdigit());

    // convert to binary string if we do have hex bytes, otherwise return read in string
    let bit_string = if is_hex {
        hex_to_bit_string(&buffer)?
    } else {
        buffer
    };

    log::info!("Read {} of random bits", bit_string.len());

    Ok(bit_string)
}

/// Write random bytes into file.
///
/// # Arguments
///
/// random_bytes - Vector containing random bytes
/// file_path - File to write the random bytes into
///
/// # Return
///
/// Ok() - Writing random bytes into file worked fine
/// Err(err) - Some error occured
pub fn write_random_bytes(random_bytes: Vec<u8>, file_path: &str) -> Result<()> {
    log::trace!("utils::write_random_bytes()");

    // check whether passed vector is empty or not
    if random_bytes.is_empty() {
        anyhow::bail!("No random bytes passed to write into file!");
    }

    // convert bytes to hexadecimal string
    let hex_string: String = random_bytes
        .iter()
        .map(|b| format!("{:02X}", b))
        .collect::<Vec<String>>()
        .join("");

    // Open the file for writing
    let mut file = File::create(file_path)
        .with_context(|| format!("Failed to create file '{}'", file_path))?;

    // Write the bytes to the file
    file.write_all(hex_string.as_bytes())
        .with_context(|| format!("Failed to write to file '{}'", file_path))?;

    Ok(())
}
